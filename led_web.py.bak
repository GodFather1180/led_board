#!/usr/bin/env python3
"""
LED Matrix Web Control (Fixed color mapping)
- Serve a simple phone-friendly web page to live-update scrolling text, speed, color, and brightness
- Works over your local Wi‑Fi (no auth by default). Use only on trusted networks.

Fix applied:
- **Hardware-only channel mapping.** Removed the extra software color remapping so colors aren't double-swapped.
- Use `--rgb-seq` (e.g. BGR/GBR) once via rpi-rgb-led-matrix options.

Run example (Pi 4 + Adafruit HAT):
  sudo python3 led_web.py --hardware-mapping adafruit-hat --rows 32 --cols 64 \
      --gpio-slowdown 5 --font /home/pi/rpi-rgb-led-matrix/fonts/7x13.bdf --rgb-seq BGR

Then visit:  http://<pi-ip>:8080  from your phone.
"""
import argparse
import json
import threading
import time
import re
from pathlib import Path
from typing import Tuple

from flask import Flask, request, jsonify, Response
from rgbmatrix import RGBMatrix, RGBMatrixOptions, graphics

# -----------------------
# Helpers
# -----------------------
HEX_RE = re.compile(r"^#?[0-9a-fA-F]{6}$")


def parse_color(s: str) -> graphics.Color:\n    if not isinstance(s, str):
        raise ValueError("color must be string")
    s = s.strip()
    if HEX_RE.match(s):
        s = s.lstrip('#')
        r, g, b = int(s[0:2], 16), int(s[2:4], 16), int(s[4:6], 16)
        return graphics.Color(r, g, b)
    if re.match(r"^\d{1,3},\d{1,3},\d{1,3}$", s):
        r, g, b = map(int, s.split(','))
        return graphics.Color(r, g, b)
    raise ValueError("Color must be #RRGGBB or R,G,B")


# Convert graphics.Color -> web hex for UI

def color_to_hex(c: graphics.Color) -> str:
    return f"#{c.red:02X}{c.green:02X}{c.blue:02X}"


# -----------------------
# Arguments
# -----------------------
ap = argparse.ArgumentParser(description="Web-controlled scrolling text for RGB LED matrix")
ap.add_argument("--text", default="HELLO WORLD!", help="Initial text")
ap.add_argument("--font", default="/home/pi/rpi-rgb-led-matrix/fonts/7x13.bdf", help="Path to .bdf font")
ap.add_argument("--color", default="#FF0000", help="Initial color (#RRGGBB or R,G,B)")
ap.add_argument("--speed", type=float, default=60.0, help="Initial speed in pixels/second")
ap.add_argument("--brightness", type=int, default=75, help="Initial brightness 0-100")
ap.add_argument("--fps", type=float, default=60.0, help="Max frame rate")
# Matrix options
ap.add_argument("--hardware-mapping", default="adafruit-hat")
ap.add_argument("--rows", type=int, default=32)
ap.add_argument("--cols", type=int, default=64)
ap.add_argument("--chain-length", type=int, default=1)
ap.add_argument("--parallel", type=int, default=1)
ap.add_argument("--gpio-slowdown", type=int, default=4)
# Advanced panel tuning
ap.add_argument("--rgb-seq", default=None, help="Color order e.g. RGB, RBG, GRB, GBR, BRG, BGR")
ap.add_argument("--row-addr-type", type=int, default=None, help="Row address type (try 0,2,4)")
ap.add_argument("--multiplexing", type=int, default=None, help="Multiplexing factor (8,16,32)")
ap.add_argument("--panel-type", default=None, help="Specific panel chipset, e.g. FM6126A")
ap.add_argument("--pixel-mapper", default=None, help="Pixel mapper config, e.g. Rotate:180")
ap.add_argument("--port", type=int, default=8080, help="Web server port")
args = ap.parse_args()

# -----------------------
# Matrix setup (hardware-only color sequence)
# -----------------------
opts = RGBMatrixOptions()
opts.hardware_mapping = args.hardware_mapping
opts.rows = args.rows
opts.cols = args.cols
opts.chain_length = args.chain_length
opts.parallel = args.parallel
opts.brightness = max(0, min(100, args.brightness))
opts.gpio_slowdown = args.gpio_slowdown
if args.rgb_seq:
    # Use rpi-rgb-led-matrix's built-in color order correction.
    opts.led_rgb_sequence = args.rgb_seq
if args.row_addr_type is not None:
    opts.row_address_type = args.row_addr_type
if args.multiplexing is not None:
    opts.multiplexing = args.multiplexing
if args.panel_type:
    opts.panel_type = args.panel_type
if args.pixel_mapper:
    opts.pixel_mapper_config = args.pixel_mapper

matrix = RGBMatrix(options=opts)
off = matrix.CreateFrameCanvas()

font = graphics.Font()
font_path = Path(args.font)
try:
    # Try to load directly; avoid pre-stat that can raise PermissionError on certain mounts
    font.LoadFont(str(font_path))
except Exception:
    # Fallback search in common locations
    candidates = [
        font_path,
        Path("/home/pi/rpi-rgb-led-matrix/fonts/7x13.bdf"),
        Path("/home/pi/led-project/fonts/7x13.bdf"),
    ]
    loaded = False
    for p in candidates:
        try:
            font.LoadFont(str(p))
            loaded = True
            break
        except Exception:
            continue
    if not loaded:
        raise FileNotFoundError(f"Could not load font. Tried: {', '.join(str(c) for c in candidates)}")

# -----------------------
# Shared state
# -----------------------
state_lock = threading.Lock()
state = {
    "text": args.text,
    "color": parse_color(args.color),
    "speed": float(args.speed),
    "brightness": int(opts.brightness),
    "fps": float(args.fps),
}

# Derived / cache
_baseline_y = (off.height + font.height) // 2 - 1
_text_width = 0
_last_text = None

# -----------------------
# Renderer Thread
# -----------------------
stop_flag = threading.Event()


def measure_text_width(canvas, font_obj, color_obj, text: str) -> int:
    canvas.Clear()
    w = graphics.DrawText(canvas, font_obj, 0, _baseline_y, color_obj, text)
    canvas.Clear()
    return w


def render_loop():
    global off, _text_width, _last_text
    x = off.width
    last_brightness = state["brightness"]

    # Initial width
    with state_lock:
        _text_width = measure_text_width(off, font, state["color"], state["text"])
        _last_text = state["text"]

    t_prev = time.monotonic()
    while not stop_flag.is_set():
        try:
            # Snapshot state
            with state_lock:
                text = state["text"]
                color = state["color"]
                speed = max(1.0, state["speed"])  # px/sec
                fps = max(1.0, min(240.0, state["fps"]))
                brightness = max(0, min(100, state["brightness"]))

            # Update brightness if changed
            if brightness != last_brightness:
                matrix.brightness = brightness
                last_brightness = brightness

            # Re-measure width if text changed
            if text != _last_text:
                _text_width = measure_text_width(off, font, color, text)
                _last_text = text
                x = off.width

            # Timing
            t_now = time.monotonic()
            dt = t_now - t_prev
            t_prev = t_now
            dt = min(dt, 0.1)
            px = max(1.0, speed * dt)

            # Draw frame
            off.Clear()
            graphics.DrawText(off, font, int(x), _baseline_y, color, text)
            off = matrix.SwapOnVSync(off)

            # Advance and wrap
            x -= px
            if x + _text_width < 0:
                x = off.width

            # Cap FPS
            target_dt = 1.0 / fps
            rem = target_dt - (time.monotonic() - t_now)
            if rem > 0:
                time.sleep(rem)
        except Exception as e:
            print(f"[render] error: {e}")
            time.sleep(0.05)


# Start renderer
thread = threading.Thread(target=render_loop, daemon=True)
thread.start()

# -----------------------
# Web server (Flask)
# -----------------------
app = Flask(__name__)

from string import Template
INDEX_HTML_TMPL = Template("""
<!doctype html>
<html lang=\"en\">
<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">
<title>LED Matrix Control</title>
<style>
  body { font-family: system-ui, Arial, sans-serif; margin: 24px; }
  .card { max-width: 520px; margin: auto; padding: 16px; border: 1px solid #ddd; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,.06); }
  label { display:block; margin-top: 12px; font-weight: 600; }
  input[type=text] { width: 100%; padding: 10px; font-size: 16px; }
  input[type=range] { width: 100%; }
  .row { display:flex; gap:12px; align-items:center; }
  .row > * { flex:1; }
  button { padding: 10px 14px; border: 0; border-radius: 10px; font-size: 16px; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,.1); }
  .save { background:#0ea5e9; color:#fff; }
  .danger { background:#ef4444; color:#fff; }
  .muted { color:#666; font-size: 13px; margin-top:8px; }
</style>
<div class=card>
  <h2>LED Matrix Control</h2>
  <label>Text</label>
  <input id=\"text\" type=\"text\" placeholder=\"Type your message\">\n
  <div class=row>
    <div>
      <label>Color</label>
      <input id=\"color\" type=\"color\" value=\"#FF0000\">
    </div>
    <div>
      <label>Brightness <span id=\"bval\"></span></label>
      <input id=\"brightness\" type=\"range\" min=\"0\" max=\"100\" step=\"1\"> 
    </div>
  </div>

  <label>Speed (px/sec) <span id=\"sval\"></span></label>
  <input id=\"speed\" type=\"range\" min=\"5\" max=\"200\" step=\"1\">\n
  <div style=\"display:flex; gap:12px; margin-top:16px;\">
    <button class=\"save\" onclick=\"save()\">Save</button>
    <button class=\"danger\" onclick=\"reset()\">Reset</button>
  </div>
  <div class=\"muted\">Connected to ${rows}x${cols}, fps max ${fps}. Open this page from the same Wi‑Fi.</div>
</div>
<script>
async function fetchState(){
  const r = await fetch('/api/state');
  const s = await r.json();
  document.getElementById('text').value = s.text;
  document.getElementById('color').value = s.color;
  document.getElementById('speed').value = s.speed;
  document.getElementById('sval').textContent = '('+s.speed+')';
  document.getElementById('brightness').value = s.brightness;
  document.getElementById('bval').textContent = '('+s.brightness+')';
}
async function save(){
  const payload = {
    text: document.getElementById('text').value,
    color: document.getElementById('color').value,
    speed: parseFloat(document.getElementById('speed').value),
    brightness: parseInt(document.getElementById('brightness').value)
  };
  await fetch('/api/update', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
}
async function reset(){
  await fetch('/api/reset', {method:'POST'});
  fetchState();
}
['speed','brightness'].forEach(id=>{
  document.addEventListener('input', (e)=>{
    if(e.target && e.target.id===id){
      const lab = id==='speed' ? 'sval' : 'bval';
      document.getElementById(lab).textContent = '('+e.target.value+')';
    }
  });
});
fetchState();
</script>
</html>
""")


@app.get("/")
def index():
    html = INDEX_HTML_TMPL.substitute(rows=args.rows, cols=args.cols, fps=int(args.fps))
    return Response(html, mimetype="text/html")


@app.get("/api/state")
def get_state():
    with state_lock:
        return jsonify({
            "text": state["text"],
            "color": color_to_hex(state["color"]),
            "speed": int(state["speed"]),
            "brightness": int(state["brightness"]),
            "fps": int(state["fps"])
        })


@app.post("/api/update")
def update():
    data = request.get_json(force=True, silent=True) or {}
    with state_lock:
        if 'text' in data:
            state['text'] = str(data['text'])[:512]
        if 'color' in data:
            try:
                state['color'] = parse_color(str(data['color']))
            except Exception:
                return jsonify({"error": "invalid color"}), 400
        if 'speed' in data:
            try:
                state['speed'] = float(data['speed'])
            except Exception:
                return jsonify({"error": "invalid speed"}), 400
        if 'brightness' in data:
            try:
                state['brightness'] = int(data['brightness'])
            except Exception:
                return jsonify({"error": "invalid brightness"}), 400
    return jsonify({"ok": True})


@app.post("/api/reset")
def reset():
    with state_lock:
        state['text'] = args.text
        state['color'] = parse_color(args.color)
        state['speed'] = float(args.speed)
        state['brightness'] = int(args.brightness)
    return jsonify({"ok": True})


# -----------------------
# Main
# -----------------------
if __name__ == "__main__":
    try:
        # Expose on all interfaces so phone can reach it
        app.run(host="0.0.0.0", port=args.port, debug=False, threaded=True)
    except KeyboardInterrupt:
        pass
    finally:
        stop_flag.set()
        thread.join(timeout=1.0)
        off.Clear()
        matrix.SwapOnVSync(off)
